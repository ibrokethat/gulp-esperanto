{
  "name": "esperanto",
  "description": "An easier way to convert ES6 modules to AMD and CommonJS",
  "version": "0.3.11",
  "author": {
    "name": "Rich Harris"
  },
  "dependencies": {
    "acorn": "~0.7.0"
  },
  "main": "lib/esperanto.js",
  "devDependencies": {
    "promo": "~0.1.1",
    "glob": "~4.0.5",
    "rimraf": "~2.2.8",
    "mkdirp": "~0.5.0",
    "gobble": "~0.2.0",
    "gobble-requirejs": "~0.1.0",
    "gobble-amdclean": "~0.1.0",
    "gobble-jsbeautify": "~0.1.0",
    "gobble-esperanto": "~0.1.0",
    "promise-map-series": "~0.2.0",
    "colors": "~0.6.2",
    "gobble-uglifyjs": "^0.1.0"
  },
  "files": [
    "index.js",
    "lib"
  ],
  "scripts": {
    "build": "scripts/build.sh",
    "test": "scripts/test.sh",
    "update-gh-pages": "scripts/update-gh-pages.sh"
  },
  "readme": "# esperanto\n\nA better way to transpile ES6 modules to AMD and CommonJS:\n\n* Easier - no laborious configuration\n* Simpler - doesn't make dangerous assumptions about your project setup\n* Smarter - non-destructive source code transformation, no runtime Traceur dependency, and no ES5-only features\n* Faster - roughly 10x quicker than the alternatives\n\nTry it online here: [rich-harris.co.uk/esperanto](http://www.rich-harris.co.uk/esperanto/)\n\n## Installation\n\n```bash\nnpm install esperanto\n```\n\n## Usage\n\n```js\nvar fs = require( 'fs' );\nvar esperanto = require( 'esperanto' );\n\nfs.readFile( 'path/to/es6/modules/foo.js', function ( err, result ) {\n  if ( err ) throw err;\n\n  fs.writeFile( 'path/to/amd/output/foo.js', esperanto.toAmd( result.toString() ) );\n  fs.writeFile( 'path/to/cjs/output/foo.js', esperanto.toCjs( result.toString() ) );\n});\n```\n\nSee the [wiki](https://github.com/Rich-Harris/esperanto/wiki) for other options.\n\n\n## Why not use existing module transpilers?\n\nThere are already a couple of ES6 module transpilers. Let's consider our example from above...\n\n```js\nimport foo from 'foo';\nvar bar = foo.toUpperCase();\nexport default bar;\n```\n\n...and see how those transpilers fare.\n\n\n### [bitovi/transpile](https://github.com/bitovi/transpile)\n\n```js\nvar transpile = require( 'transpile' );\n\nvar transpiled = transpile.to({\n  name: 'test',\n  source: test, // the contents of the module\n  metadata: { format: 'es6' }\n}, 'amd' );\n```\n\nPretty easy - we just tell it what input and output formats to use, and off it goes. It's a bit of a shame that you have to specify a `name` property, since AMD best practice is to use anonymous modules, but never mind. What does the result look like?\n\n```js\ndefine('sample', ['foo'], function ($__0) {\n  'use strict';\n  if (!$__0 || !$__0.__esModule)\n    $__0 = { 'default': $__0 };\n  var foo = $traceurRuntime.assertObject($__0).default;\n  var bar = foo.toUpperCase();\n  var $__default = bar;\n  return {\n    get default() {\n      return $__default;\n    },\n    __esModule: true\n  };\n});\n```\n\nWait, I'm supposed to use Traceur in production? No thanks! Oh, and I still need to support IE8, so that `get default()` is a no-go.\n\n\n###  [esnext/es6-module-transpiler](https://github.com/esnext/es6-module-transpiler)\n\n```js\nvar transpiler = require( 'es6-module-transpiler' );\nvar Container = transpiler.Container;\nvar FileResolver = transpiler.FileResolver;\nvar BundleFormatter = transpiler.formatters.bundle;\nvar AmdFormatter = require( 'es6-module-transpiler-amd-formatter' );\n\nvar container = new Container({\n  resolvers: [new FileResolver(['./'])],\n  formatter: new AmdFormatter()\n});\n\ncontainer.getModule('test');\ncontainer.write('output/test.js');\n```\n\nThis time, rather than passing in a string, we have to point the transpiler to the files on disk. That's because it actually follows the dependency graph of your modules, so that it can (if you're not using the [AMD formatter](https://github.com/caridy/es6-module-transpiler-amd-formatter)) bundle up your source code into a single file. If it can't find a module, it errors out - so as far as I can tell, it's impossible to use es6-module-transpiler if you have external dependencies (e.g. in a `bower_components` folder) that aren't packaged as ES6 modules.\n\nLeaving that aside, what does the result look like?\n\n```js\ndefine(\"test\", [\"foo\", \"exports\"], function(foo$$, __exports__) {\n  \"use strict\";\n\n  function __es6_export__(name, value) {\n    __exports__[name] = value;\n  }\n\n  var foo;\n  foo = foo$$[\"default\"];\n  var bar = foo.toUpperCase();\n  __es6_export__(\"default\", bar);\n});\n\n//# sourceMappingURL=es6-module-transpiler.js.map\n```\n\nBetter, certainly, and you get source maps which is really cool. Though as with [transpile](https://github.com/bitovi/transpile), you're stuck with named (as opposed to anonymous) AMD modules. Frankly, though, the external dependencies thing is a dealbreaker for me.\n\n\n### [esperanto](http://www.rich-harris.co.uk/esperanto/)\n\nHere's the code to generate AMD output:\n\n```js\nvar transpiled = esperanto.toAmd( test );\n```\n\nAnd here's the output:\n\n```js\ndefine(['foo','exports'], function (__imports_0,exports) {\n\n  'use strict';\n\n  var foo = __imports_0.default;\n  var bar = foo.toUpperCase();\n  exports.default = bar;\n\n});\n```\n\nIf we run it in `defaultOnly` mode...\n\n```js\nvar transpiled = esperanto.toAmd( test, { defaultOnly: true });\n```\n\n```js\ndefine(['foo'],function (foo) {\n\n  'use strict';\n\n  var bar = foo.toUpperCase();\n  return bar;\n\n});\n```\n\nNo muss, no fuss. Oh, and did I mention that it's an order of magnitude faster than the alternatives? See [here](https://github.com/Rich-Harris/esperanto/tree/master/comparison) for more comparisons.\n\n\n## Still to-do\n\n* Command line mode\n* Source maps... maybe\n* Allow named modules, if you're into that\n\n\n## Credits\n\nMany thanks to [Marijn Haverbeke](http://marijnhaverbeke.nl/) for [Acorn](https://github.com/marijnh/acorn), which does all the heavy lifting.\n\n\n## License\n\nCopyright 2014 Rich Harris. MIT Licensed.\n",
  "readmeFilename": "README.md",
  "_id": "esperanto@0.3.11",
  "_shasum": "49db1dbda247b23e272b0b46c06f43260560ed41",
  "_from": "esperanto@^0.3.11",
  "_resolved": "https://registry.npmjs.org/esperanto/-/esperanto-0.3.11.tgz"
}
